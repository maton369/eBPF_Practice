#!/usr/bin/python3
# =============================================================================
# BCC を使った eBPF "Hello World" (kprobe + bpf_trace_printk) の最小例
# =============================================================================
#
# 目的
#   execve 系システムコール（= 新しいプログラムを実行する処理）のカーネル実装関数に
#   kprobe を仕掛け、呼ばれるたびにカーネル側 eBPF から "Hello World!" を出力する。
#
# このコードで学べること（全体像）
#   1) ユーザ空間(Python) から eBPF プログラムをロードする
#   2) kprobe で「カーネル関数の入口」をフックする
#   3) eBPF 側で bpf_trace_printk を使い、trace_pipe にログを流す
#   4) ユーザ空間で trace_pipe を読み続けて表示する
#
# 注意（重要）
#   - eBPF のロードや kprobe の attach には通常 root 権限が必要。
#   - bpf_trace_printk はデバッグ用途（遅い／出力制限あり）で、本格的には
#     ring buffer / perf buffer / map でユーザ空間へデータを渡す。
#   - execve は OS 全体で頻繁に呼ばれるため、ログが洪水になりやすい。
#     今回あなたのログに apt-check / update-notifier が大量に出たのは正常。
#
# 実行時の典型
#   sudo /usr/bin/python3 hello.py
#
# =============================================================================

from bcc import BPF
import sys

# -----------------------------------------------------------------------------
# eBPF プログラム本体（C 風のコードを文字列として埋め込む）
# -----------------------------------------------------------------------------
# BCC はこの文字列を:
#   - clang/LLVM で BPF バイトコードへコンパイル
#   - bpf(BPF_PROG_LOAD, ...) でカーネルへロード
# する。
#
# eBPF は「カーネル空間で安全に動く」必要があるため、ロード時に verifier が検証する。
# ここでは危険なメモリアクセス等をしていないので通りやすい。
#
# `r""" ... """` の r は raw 文字列で、\n などのエスケープを意識せず書ける。
program = r"""
int hello(void *ctx) {
    // ---------------------------------------------------------
    // bpf_trace_printk:
    //   カーネル空間から tracing サブシステムへ文字列を出すデバッグ用 helper。
    //
    // 出力先:
    //   /sys/kernel/debug/tracing/trace_pipe
    //   または /sys/kernel/tracing/trace_pipe (環境による)
    //
    // 制約/注意:
    //   - デバッグ用途で遅い（頻繁なイベントだと性能が落ちる）
    //   - 出力できる文字列やフォーマットが制限される
    //   - ログが多いと trace バッファが埋まり、ドロップすることがある
    //
    // 今回は最小例として固定文字列を出すだけにしている。
    bpf_trace_printk("Hello World!");
    return 0;
}
"""

# -----------------------------------------------------------------------------
# eBPF のコンパイル＆ロード
# -----------------------------------------------------------------------------
# BPF(text=program) の時点で:
#   - eBPF をコンパイル
#   - カーネルへロード可能なオブジェクトを構築
# が行われる。
#
# ここで失敗する場合の典型:
#   - bcc/python バインディング不足
#   - kernel headers 不一致
#   - verifier に弾かれた
b = BPF(text=program)

# -----------------------------------------------------------------------------
# execve の「実際のカーネル関数名」を解決する
# -----------------------------------------------------------------------------
# 重要ポイント:
#   ユーザが知っている syscall 名は "execve" でも、
#   カーネル内部の実装関数名は環境で異なることがある。
#
# 例（ありがちな差分）:
#   - __x64_sys_execve
#   - __arm64_sys_execve
#   - sys_execve
#   - __se_sys_execve
#
# これを手で決め打ちすると、別環境で動かない。
# BCC の get_syscall_fnname("execve") は「この環境の正しい名前」を返す。
syscall = b.get_syscall_fnname("execve")

# -----------------------------------------------------------------------------
# kprobe を attach（カーネル関数の入口にフック）
# -----------------------------------------------------------------------------
# attach_kprobe(event=..., fn_name=...):
#   - event: フック対象のカーネル関数名
#   - fn_name: 発火したときに呼ぶ eBPF 関数名（program 内で定義した hello）
#
# これにより、カーネルが execve 実装関数へ入る瞬間に hello(ctx) が実行される。
#
# ここが失敗するときの典型:
#   - root 権限がない（Need super-user privileges / EPERM）
#   - 対象関数が存在しない（関数名解決ミス）
#   - カーネルのセキュリティ設定で禁止されている
b.attach_kprobe(event=syscall, fn_name="hello")

# -----------------------------------------------------------------------------
# trace_pipe を読み続けて表示する（Ctrl+C まで）
# -----------------------------------------------------------------------------
# b.trace_print():
#   bpf_trace_printk の出力を、ユーザ空間で読み続ける便利関数。
#
# あなたの実行ログで:
#   update-notifier, apt-check, lsb_release などが大量に出たのは、
#   それらのプロセスが execve を呼び、kprobe が発火したため。
#
# 出力行の構造（概略）:
#   <comm>-<pid> [cpu] ... <timestamp>: bpf_trace_printk: Hello World!
#
# comm:
#   その時点のプロセス名（例: apt-check）
# pid:
#   プロセスID
# cpu:
#   実行されたCPU番号
# timestamp:
#   tracing のタイムスタンプ（秒）
try:
    b.trace_print()
except KeyboardInterrupt:
    # Ctrl+C で終了したときの後始末
    sys.exit(0)

# =============================================================================
# 次の一歩（発展の方向性）
# =============================================================================
# - ログ洪水を抑える: PID/comm/UID でフィルタする
# - printk を卒業する: ring buffer / perf buffer / map で構造化データを渡す
# - 安定性を上げる: kprobe ではなく tracepoint を使う（用途次第）
# =============================================================================
