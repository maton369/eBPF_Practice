# ============================================================
# eBPF(XDP) 用 Makefile
#
# 目的:
#   - hello.bpf.c / hello-func.bpf.c を clang で BPF バイトコード(.bpf.o)にコンパイルする
#   - all ターゲットで複数の BPF オブジェクトをまとめてビルドする
#   - clean ターゲットで生成物と、/sys/fs/bpf にピン留めしたオブジェクトを掃除する
#
# 用語メモ:
#   - eBPF プログラムは通常「.bpf.c」を BPF ターゲットでコンパイルして「.bpf.o」を作る。
#   - 生成される .bpf.o は、ユーザ空間ローダ（bpftool / libbpf を使う自作ローダ等）から
#     ロードされ、XDP フックにアタッチされる。
#   - /sys/fs/bpf は BPF FS (bpffs) のマウントポイントで、
#     map や link や program を "pin" して永続参照するのに使うことが多い。
# ============================================================


# ------------------------------------------------------------
# ビルド対象の "ベース名" を列挙する
#
# ここに書いた名前 X に対して:
#   - X.bpf.c がソース
#   - X.bpf.o がビルド成果物
# という規約でルールが動く。
# ------------------------------------------------------------
TARGETS = hello hello-func


# ------------------------------------------------------------
# デフォルトターゲット: all
# all を実行すると TARGETS の各ターゲットをビルドする。
#
# Make は一番上にあるターゲットをデフォルトにすることが多いので、
# 先頭で all を宣言しておくのは一般的。
# ------------------------------------------------------------
all: $(TARGETS)

# ------------------------------------------------------------
# .PHONY は "ファイル名と衝突しうるターゲット" を phony として宣言する。
# これにより、たとえばカレントディレクトリに "all" というファイルが存在しても
# "all" をターゲットとして必ず実行してくれる。
# ------------------------------------------------------------
.PHONY: all


# ------------------------------------------------------------
# パターンルール 1:
#   $(TARGETS): %: %.bpf.o
#
# 意味:
#   - hello というターゲットを作るには hello.bpf.o が必要
#   - hello-func というターゲットを作るには hello-func.bpf.o が必要
#
# 注意:
#   - このルール自体は "hello" というファイルを生成しない。
#     ただ依存関係として .bpf.o を要求するだけ。
#   - つまり「hello を作った」といっても実体は hello.bpf.o の生成がゴールになっている。
#
#   もし "hello" という名前のファイル（ローダバイナリ等）も作りたい場合は
#   このルールとは別に hello: hello.c ... のような生成ルールが必要になる。
# ------------------------------------------------------------
$(TARGETS): %: %.bpf.o


# ------------------------------------------------------------
# パターンルール 2:
#   %.bpf.o: %.bpf.c
#
# 意味:
#   - 例: hello.bpf.o は hello.bpf.c から生成する
#   - 例: hello-func.bpf.o は hello-func.bpf.c から生成する
#
# ここが eBPF 生成の本体。
# ------------------------------------------------------------
%.bpf.o: %.bpf.c
	# clang を使って eBPF ターゲット向けにコンパイルする
	#
	# -target bpf:
	#   clang に BPF バックエンドを使わせ、eBPF バイトコードを出力させる
	#
	# -I/usr/include/$(shell uname -m)-linux-gnu:
	#   ディストリ依存で置かれているアーキ依存の include パスを追加する。
	#   例: x86_64-linux-gnu, aarch64-linux-gnu など。
	#
	# -g:
	#   デバッグ情報を付与する（bpftool prog dump xlated/jited などで役に立つことがある）
	#
	# -O2:
	#   最適化。BPF は検証器(Verifier)の都合もあるので、過度な最適化よりまずは O2 が定番。
	#
	# -o $@:
	#   出力ファイル名（ターゲット名）。このルールでは "%.bpf.o" に該当するファイル。
	#
	# -c $<:
	#   コンパイルのみ（リンクしない）。入力は最初の依存ファイル（= "%.bpf.c"）。
	clang \
	    -target bpf \
		-I/usr/include/$(shell uname -m)-linux-gnu \
		-g \
	    -O2 -o $@ -c $<


# ------------------------------------------------------------
# clean ターゲット:
#   - 生成した .bpf.o を削除する
#   - /sys/fs/bpf に pin していると想定されるオブジェクトも削除する
#
# 先頭の "-" は「コマンドが失敗しても make を止めない」という意味。
# 例:
#   すでにファイルが無くて rm が失敗しても clean は最後まで走る。
#
# 注意:
#   /sys/fs/bpf の削除は root 権限が必要なことが多い。
#   実行ユーザに権限がないと消せないが、"-" により make 自体は止まらない。
# ------------------------------------------------------------
clean:
	- rm *.bpf.o
	- rm -f /sys/fs/bpf/hello
	- rm -f /sys/fs/bpf/hello-func

# clean も phony 宣言しておくとより安全（同名ファイルがあっても必ず実行される）
.PHONY: clean
